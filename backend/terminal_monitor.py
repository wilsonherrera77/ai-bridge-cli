#!/usr/bin/env python3
"""
TerminalMonitor - Real-time CLI Process Health and Activity Monitor
Supervises CLI terminal processes and provides comprehensive monitoring.

Características:
- Monitor de salud de procesos CLI en tiempo real
- Detección de crashes y auto-restart
- Métricas de rendimiento y actividad
- Alertas de problemas de comunicación
- Dashboard de estado en tiempo real
"""

import asyncio
import logging
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False
    psutil = None
import json
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, List, Optional, Callable, Union
from dataclasses import dataclass, asdict
from enum import Enum
import threading
import time

logger = logging.getLogger(__name__)

class HealthStatus(Enum):
    """CLI process health status"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    UNRESPONSIVE = "unresponsive"
    CRASHED = "crashed"
    UNKNOWN = "unknown"

class AlertLevel(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class ProcessMetrics:
    """Metrics for CLI process monitoring"""
    process_id: str
    pid: Optional[int]
    cpu_percent: float
    memory_mb: float
    uptime_seconds: int
    message_count: int
    error_count: int
    restart_count: int
    last_activity: datetime
    health_status: HealthStatus
    response_time_avg: float
    response_time_max: float
    is_responding: bool
    
@dataclass
class MonitorAlert:
    """Alert generated by monitoring system"""
    id: str
    process_id: str
    level: AlertLevel
    message: str
    timestamp: datetime
    resolved: bool = False
    acknowledged: bool = False

class TerminalMonitor:
    """
    Comprehensive monitoring system for CLI terminal processes.
    
    Features:
    - Real-time process health monitoring
    - Performance metrics collection
    - Automatic crash detection and restart
    - Response time tracking
    - Memory and CPU usage monitoring
    - Alert generation and notification
    - Historical metrics storage
    """
    
    def __init__(self, terminal_manager=None):
        self.terminal_manager = terminal_manager
        self.monitoring_active = False
        self.monitor_task: Optional[asyncio.Task] = None
        
        # Metrics storage
        self.current_metrics: Dict[str, ProcessMetrics] = {}
        self.historical_metrics: Dict[str, List[ProcessMetrics]] = {}
        self.alerts: List[MonitorAlert] = []
        
        # Monitoring configuration
        self.check_interval = 5  # seconds
        self.max_response_time = 30  # seconds
        self.max_memory_mb = 1024  # MB
        self.max_cpu_percent = 80  # %
        self.max_history_entries = 1000
        
        # Health check configuration
        self.health_check_timeout = 10
        self.unhealthy_threshold = 3  # consecutive failures
        self.restart_cooldown = 60  # seconds between restarts
        
        # Callbacks for alerts and events
        self.alert_callbacks: List[Callable[[MonitorAlert], None]] = []
        self.restart_callbacks: List[Callable[[str], None]] = []
        
        logger.info("TerminalMonitor initialized - Ready to monitor CLI processes")
    
    def register_alert_callback(self, callback: Callable[[MonitorAlert], None]):
        """Register callback for alert notifications"""
        self.alert_callbacks.append(callback)
    
    def register_restart_callback(self, callback: Callable[[str], None]):
        """Register callback for restart notifications"""
        self.restart_callbacks.append(callback)
    
    async def start_monitoring(self):
        """Start continuous monitoring of CLI processes"""
        if self.monitoring_active:
            logger.warning("Monitoring already active")
            return
        
        self.monitoring_active = True
        self.monitor_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info("TerminalMonitor started - Continuous process monitoring active")
    
    async def stop_monitoring(self):
        """Stop continuous monitoring"""
        self.monitoring_active = False
        
        if self.monitor_task:
            self.monitor_task.cancel()
            try:
                await self.monitor_task
            except asyncio.CancelledError:
                pass
        
        logger.info("TerminalMonitor stopped")
    
    async def _monitoring_loop(self):
        """Main monitoring loop"""
        logger.info("Starting monitoring loop")
        
        try:
            while self.monitoring_active:
                # Get all processes from terminal manager
                if self.terminal_manager:
                    processes = self.terminal_manager.list_processes()
                    
                    # Monitor each process
                    for process_info in processes:
                        await self._monitor_process(process_info)
                
                # Cleanup old metrics
                self._cleanup_historical_metrics()
                
                # Wait before next check
                await asyncio.sleep(self.check_interval)
                
        except Exception as e:
            logger.error(f"Error in monitoring loop: {e}")
            # Generate critical alert
            await self._generate_alert(
                "monitor_system",
                AlertLevel.CRITICAL,
                f"Monitoring system error: {e}"
            )
    
    async def _monitor_process(self, process_info: Dict[str, Any]):
        """Monitor individual CLI process"""
        process_id = process_info["id"]
        pid = process_info.get("pid")
        
        try:
            # Collect system metrics
            system_metrics = await self._collect_system_metrics(pid)
            
            # Collect application metrics
            app_metrics = self._extract_app_metrics(process_info)
            
            # Perform health check
            health_status = await self._perform_health_check(process_id, process_info)
            
            # Calculate response times
            response_times = self._calculate_response_times(process_id)
            
            # Create metrics record
            metrics = ProcessMetrics(
                process_id=process_id,
                pid=pid,
                cpu_percent=system_metrics.get("cpu_percent", 0.0),
                memory_mb=system_metrics.get("memory_mb", 0.0),
                uptime_seconds=self._calculate_uptime(process_info),
                message_count=app_metrics.get("message_count", 0),
                error_count=app_metrics.get("error_count", 0),
                restart_count=app_metrics.get("restart_count", 0),
                last_activity=self._parse_last_activity(process_info),
                health_status=health_status,
                response_time_avg=response_times.get("avg", 0.0),
                response_time_max=response_times.get("max", 0.0),
                is_responding=health_status != HealthStatus.UNRESPONSIVE
            )
            
            # Store metrics
            self.current_metrics[process_id] = metrics
            
            # Add to historical data
            if process_id not in self.historical_metrics:
                self.historical_metrics[process_id] = []
            self.historical_metrics[process_id].append(metrics)
            
            # Check for alerts
            await self._check_alerts(metrics)
            
        except Exception as e:
            logger.error(f"Error monitoring process {process_id}: {e}")
            await self._generate_alert(
                process_id,
                AlertLevel.ERROR,
                f"Monitoring error: {e}"
            )
    
    async def _collect_system_metrics(self, pid: Optional[int]) -> Dict[str, float]:
        """Collect system-level metrics for process"""
        if not pid or not PSUTIL_AVAILABLE:
            return {"cpu_percent": 0.0, "memory_mb": 0.0}
        
        try:
            process = psutil.Process(pid)
            
            # Get CPU and memory usage
            cpu_percent = process.cpu_percent(interval=1.0)
            memory_info = process.memory_info()
            memory_mb = memory_info.rss / (1024 * 1024)  # Convert to MB
            
            return {
                "cpu_percent": cpu_percent,
                "memory_mb": memory_mb
            }
            
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            return {"cpu_percent": 0.0, "memory_mb": 0.0}
    
    def _extract_app_metrics(self, process_info: Dict[str, Any]) -> Dict[str, Any]:
        """Extract application-specific metrics"""
        return {
            "message_count": process_info.get("message_count", 0),
            "error_count": process_info.get("error_count", 0),
            "restart_count": process_info.get("restart_count", 0),
            "status": process_info.get("status", "unknown")
        }
    
    async def _perform_health_check(self, process_id: str, process_info: Dict[str, Any]) -> HealthStatus:
        """Perform comprehensive health check on CLI process"""
        
        # Check if process is running
        if not process_info.get("is_running", False):
            return HealthStatus.CRASHED
        
        # Check last activity
        last_activity = self._parse_last_activity(process_info)
        if last_activity:
            time_since_activity = (datetime.now(timezone.utc) - last_activity).total_seconds()
            if time_since_activity > 300:  # 5 minutes
                return HealthStatus.UNRESPONSIVE
        
        # Check error rate
        error_count = process_info.get("error_count", 0)
        message_count = process_info.get("message_count", 1)
        error_rate = error_count / max(message_count, 1)
        
        if error_rate > 0.5:  # More than 50% errors
            return HealthStatus.CRITICAL
        elif error_rate > 0.2:  # More than 20% errors
            return HealthStatus.WARNING
        
        # Check response time (if available)
        if process_id in self.current_metrics:
            current = self.current_metrics[process_id]
            if current.response_time_avg > self.max_response_time:
                return HealthStatus.WARNING
        
        return HealthStatus.HEALTHY
    
    def _calculate_response_times(self, process_id: str) -> Dict[str, float]:
        """Calculate response time statistics"""
        if process_id not in self.historical_metrics:
            return {"avg": 0.0, "max": 0.0, "min": 0.0}
        
        # Get recent metrics (last 20 entries)
        recent_metrics = self.historical_metrics[process_id][-20:]
        
        if not recent_metrics:
            return {"avg": 0.0, "max": 0.0, "min": 0.0}
        
        response_times = [m.response_time_avg for m in recent_metrics if m.response_time_avg > 0]
        
        if not response_times:
            return {"avg": 0.0, "max": 0.0, "min": 0.0}
        
        return {
            "avg": sum(response_times) / len(response_times),
            "max": max(response_times),
            "min": min(response_times)
        }
    
    def _calculate_uptime(self, process_info: Dict[str, Any]) -> int:
        """Calculate process uptime in seconds"""
        created_at = process_info.get("created_at")
        if not created_at:
            return 0
        
        try:
            created_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
            uptime = (datetime.now(timezone.utc) - created_time).total_seconds()
            return int(uptime)
        except:
            return 0
    
    def _parse_last_activity(self, process_info: Dict[str, Any]) -> Optional[datetime]:
        """Parse last activity timestamp"""
        last_activity = process_info.get("last_activity")
        if not last_activity:
            return None
        
        try:
            return datetime.fromisoformat(last_activity.replace('Z', '+00:00'))
        except:
            return None
    
    async def _check_alerts(self, metrics: ProcessMetrics):
        """Check metrics against alert thresholds"""
        
        # CPU usage alert
        if metrics.cpu_percent > self.max_cpu_percent:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.WARNING,
                f"High CPU usage: {metrics.cpu_percent:.1f}%"
            )
        
        # Memory usage alert
        if metrics.memory_mb > self.max_memory_mb:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.WARNING,
                f"High memory usage: {metrics.memory_mb:.1f} MB"
            )
        
        # Health status alerts
        if metrics.health_status == HealthStatus.CRITICAL:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.CRITICAL,
                "Process health critical - high error rate"
            )
        elif metrics.health_status == HealthStatus.CRASHED:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.CRITICAL,
                "Process crashed - restart required"
            )
            # Trigger restart if terminal manager is available
            await self._attempt_restart(metrics.process_id)
            
        elif metrics.health_status == HealthStatus.UNRESPONSIVE:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.ERROR,
                "Process unresponsive - no activity detected"
            )
        
        # Response time alert
        if metrics.response_time_avg > self.max_response_time:
            await self._generate_alert(
                metrics.process_id,
                AlertLevel.WARNING,
                f"Slow response time: {metrics.response_time_avg:.1f}s"
            )
    
    async def _generate_alert(self, process_id: str, level: AlertLevel, message: str):
        """Generate and broadcast alert"""
        alert = MonitorAlert(
            id=f"alert_{int(time.time())}_{process_id}",
            process_id=process_id,
            level=level,
            message=message,
            timestamp=datetime.now(timezone.utc)
        )
        
        self.alerts.append(alert)
        
        # Call registered callbacks
        for callback in self.alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                logger.error(f"Error calling alert callback: {e}")
        
        logger.warning(f"ALERT [{level.value}] {process_id}: {message}")
    
    async def _attempt_restart(self, process_id: str):
        """Attempt to restart failed CLI process"""
        if not self.terminal_manager:
            logger.warning("Cannot restart process - no terminal manager available")
            return
        
        try:
            logger.info(f"Attempting to restart process: {process_id}")
            
            # Stop the failed process
            await self.terminal_manager.stop_terminal(process_id)
            
            # Wait for cooldown
            await asyncio.sleep(5)
            
            # Restart process (this would need to be implemented in terminal manager)
            # For now, just log the attempt
            logger.info(f"Process restart attempted for: {process_id}")
            
            # Call restart callbacks
            for callback in self.restart_callbacks:
                try:
                    callback(process_id)
                except Exception as e:
                    logger.error(f"Error calling restart callback: {e}")
                    
        except Exception as e:
            logger.error(f"Error restarting process {process_id}: {e}")
            await self._generate_alert(
                process_id,
                AlertLevel.CRITICAL,
                f"Restart failed: {e}"
            )
    
    def _cleanup_historical_metrics(self):
        """Clean up old historical metrics to prevent memory leaks"""
        for process_id in self.historical_metrics:
            metrics_list = self.historical_metrics[process_id]
            if len(metrics_list) > self.max_history_entries:
                self.historical_metrics[process_id] = metrics_list[-self.max_history_entries:]
        
        # Clean up old alerts (keep last 1000)
        if len(self.alerts) > 1000:
            self.alerts = self.alerts[-1000:]
    
    def get_current_metrics(self, process_id: Optional[str] = None) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """Get current metrics for process(es)"""
        if process_id:
            if process_id in self.current_metrics:
                return asdict(self.current_metrics[process_id])
            else:
                return {"error": "Process not found"}
        else:
            return [asdict(metrics) for metrics in self.current_metrics.values()]
    
    def get_historical_metrics(self, process_id: str, limit: int = 100) -> List[Dict[str, Any]]:
        """Get historical metrics for process"""
        if process_id not in self.historical_metrics:
            return []
        
        metrics_list = self.historical_metrics[process_id]
        return [asdict(m) for m in metrics_list[-limit:]]
    
    def get_alerts(self, process_id: Optional[str] = None, unresolved_only: bool = False) -> List[Dict[str, Any]]:
        """Get alerts with optional filtering"""
        filtered_alerts = self.alerts
        
        if process_id:
            filtered_alerts = [a for a in filtered_alerts if a.process_id == process_id]
        
        if unresolved_only:
            filtered_alerts = [a for a in filtered_alerts if not a.resolved]
        
        return [asdict(alert) for alert in filtered_alerts]
    
    def acknowledge_alert(self, alert_id: str):
        """Acknowledge an alert"""
        for alert in self.alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                logger.info(f"Alert acknowledged: {alert_id}")
                return True
        
        return False
    
    def resolve_alert(self, alert_id: str):
        """Resolve an alert"""
        for alert in self.alerts:
            if alert.id == alert_id:
                alert.resolved = True
                logger.info(f"Alert resolved: {alert_id}")
                return True
        
        return False
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """Get comprehensive dashboard data"""
        total_processes = len(self.current_metrics)
        healthy_processes = len([m for m in self.current_metrics.values() if m.health_status == HealthStatus.HEALTHY])
        total_alerts = len([a for a in self.alerts if not a.resolved])
        critical_alerts = len([a for a in self.alerts if a.level == AlertLevel.CRITICAL and not a.resolved])
        
        return {
            "overview": {
                "total_processes": total_processes,
                "healthy_processes": healthy_processes,
                "unhealthy_processes": total_processes - healthy_processes,
                "total_alerts": total_alerts,
                "critical_alerts": critical_alerts,
                "monitoring_active": self.monitoring_active
            },
            "processes": [asdict(metrics) for metrics in self.current_metrics.values()],
            "recent_alerts": [asdict(a) for a in self.alerts[-10:]]  # Last 10 alerts
        }