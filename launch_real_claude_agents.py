#!/usr/bin/env python3
"""
Lanzador de Agentes Claude CLI Reales
Sistema para que 2 agentes Claude trabajen aut√≥nomamente en motor de descubrimiento
"""

import asyncio
import subprocess
import logging
import time
import os
import json
from pathlib import Path
from datetime import datetime
import click

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class RealClaudeAgent:
    """Agente Claude CLI real con comunicaci√≥n bidireccional"""
    
    def __init__(self, name: str, role: str, output_dir: Path):
        self.name = name
        self.role = role
        self.output_dir = output_dir
        self.process: subprocess.Popen = None
        self.is_active = False
        self.conversation_file = output_dir / f"{name.lower()}_conversation.log"
        self.code_output_dir = output_dir / f"{name.lower()}_code"
        self.code_output_dir.mkdir(exist_ok=True)
        
    async def start_claude_cli(self):
        """Iniciar proceso Claude CLI real"""
        try:
            logger.info(f"üöÄ Iniciando {self.name} con Claude CLI real...")
            
            # Verificar que Claude CLI est√© disponible
            result = subprocess.run(['claude', '--version'], capture_output=True, text=True)
            if result.returncode != 0:
                logger.error(f"‚ùå Claude CLI no encontrado. Instala con: npm install -g @anthropic-ai/claude-cli")
                return False
            
            logger.info(f"‚úÖ Claude CLI detectado: {result.stdout.strip()}")
            
            # Iniciar Claude CLI interactivo
            self.process = subprocess.Popen(
                ['claude', 'chat', '--interactive'],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            self.is_active = True
            logger.info(f"‚úÖ {self.name} Claude CLI iniciado (PID: {self.process.pid})")
            
            # Enviar configuraci√≥n inicial
            await self._send_initial_setup()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error iniciando {self.name}: {e}")
            return False
    
    async def _send_initial_setup(self):
        """Enviar configuraci√≥n inicial al agente"""
        
        setup_message = f"""
üéØ AGENTE {self.role.upper()} SPECIALIST - CONFIGURACI√ìN INICIAL

Eres un agente aut√≥nomo especializado en {self.role} para el Motor de Descubrimiento en Tiempo Real.

IMPORTANTE: Todos tus archivos de c√≥digo deben guardarse en: {self.code_output_dir}

AUTONOM√çA: M√ÅXIMA
- Implementa soluci√≥n COMPLETA sin supervisi√≥n
- Toma decisiones t√©cnicas ejecutivas
- C√≥digo production-ready y enterprise-grade
- Contin√∫a hasta completar 100% del objetivo

INSTRUCCIONES DE GUARDADO:
1. Crea archivos .py en {self.code_output_dir}/
2. Usa nombres descriptivos: discovery_cli.py, web_provider.py, etc.
3. Incluye comentarios y documentaci√≥n
4. Aseg√∫rate que el c√≥digo sea ejecutable

Confirma que entiendes tu rol y el directorio de trabajo.
"""
        
        await self._send_message(setup_message)
    
    async def _send_message(self, message: str):
        """Enviar mensaje al agente Claude"""
        if self.is_active and self.process:
            try:
                self.process.stdin.write(message + '\n\n')
                self.process.stdin.flush()
                
                # Registrar en archivo de conversaci√≥n
                with open(self.conversation_file, 'a', encoding='utf-8') as f:
                    f.write(f"\n[{datetime.now().isoformat()}] ENVIADO:\n{message}\n{'='*60}\n")
                
                logger.info(f"üì§ {self.name}: Mensaje enviado")
                
            except Exception as e:
                logger.error(f"‚ùå {self.name}: Error enviando mensaje: {e}")
    
    async def send_mission(self, mission: str):
        """Enviar misi√≥n espec√≠fica al agente"""
        logger.info(f"üéØ Enviando misi√≥n a {self.name}...")
        await self._send_message(mission)
    
    async def read_output(self):
        """Leer output del agente (no bloqueante)"""
        if self.is_active and self.process:
            try:
                # Verificar si hay output disponible
                output = []
                while True:
                    line = self.process.stdout.readline()
                    if not line:
                        break
                    output.append(line.strip())
                    
                    # Registrar en archivo de conversaci√≥n
                    with open(self.conversation_file, 'a', encoding='utf-8') as f:
                        f.write(f"[{datetime.now().isoformat()}] RECIBIDO: {line}")
                
                if output:
                    logger.info(f"üì• {self.name}: {len(output)} l√≠neas recibidas")
                    
                return output
                
            except Exception as e:
                logger.error(f"‚ùå {self.name}: Error leyendo output: {e}")
                return []
    
    def stop(self):
        """Detener agente"""
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
                logger.info(f"üõë {self.name} detenido")
            except:
                self.process.kill()
                logger.info(f"üõë {self.name} terminado forzosamente")
            finally:
                self.is_active = False

class RealAgentOrchestrator:
    """Orquestador para agentes Claude CLI reales"""
    
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.agent_frontend = RealClaudeAgent("AgentA", "Frontend", output_dir)
        self.agent_backend = RealClaudeAgent("AgentB", "Backend", output_dir)
        
        self.session_log = output_dir / "session.log"
        self.results_dir = output_dir / "results"
        self.results_dir.mkdir(exist_ok=True)
        
    async def setup_agents(self):
        """Configurar ambos agentes Claude CLI"""
        logger.info("üöÄ CONFIGURANDO AGENTES CLAUDE CLI REALES")
        
        # Intentar iniciar ambos agentes
        frontend_ok = await self.agent_frontend.start_claude_cli()
        backend_ok = await self.agent_backend.start_claude_cli()
        
        if not frontend_ok or not backend_ok:
            logger.error("‚ùå No se pudieron iniciar los agentes Claude CLI")
            logger.info("üí° Aseg√∫rate de tener Claude CLI instalado: npm install -g @anthropic-ai/claude-cli")
            logger.info("üí° Y autenticado: claude auth")
            return False
        
        logger.info("‚úÖ Ambos agentes Claude CLI iniciados exitosamente")
        return True
    
    async def assign_discovery_mission(self):
        """Asignar misi√≥n espec√≠fica del motor de descubrimiento"""
        
        frontend_mission = f"""
üéØ MISI√ìN CR√çTICA: MOTOR DE DESCUBRIMIENTO - FRONTEND SPECIALIST

OBJETIVO PRINCIPAL:
Construir motor de descubrimiento en tiempo real que ingiera Excel con temas/consultas,
busque exhaustivamente, extraiga metadatos, deduplique y ejecute continuamente.

TU RESPONSABILIDAD ESPEC√çFICA (FRONTEND):

1. CLI COMPLETA:
   - Usar Click para par√°metros: --excel, --continuous, --interval, --max-per-topic, --max-crawl-per-domain, --depth
   - Validaci√≥n robusta de Excel con columnas: topic, query?, platform?, seed_url?, account?, lang?, region?, depth?, recency_days?
   - Manejo de errores y help detallado

2. FORMATOS DE SALIDA CONFIGURABLES:
   - JSONL para streaming 
   - CSV para an√°lisis
   - SQLite para queries
   - Excel resumen ejecutivo
   - Usuario configura destino: {self.results_dir}

3. PARSING Y VALIDACI√ìN:
   - Parser robusto con pandas/openpyxl
   - Validaci√≥n de columnas y datos
   - Configuraci√≥n por filas del Excel

4. COORDINACI√ìN CON BACKEND:
   - Define interfaz clara para recibir resultados de crawling
   - Especifica formato DiscoveredItem esperado
   - Integra con motor de backend

DIRECTORIO DE TRABAJO: {self.agent_frontend.code_output_dir}
RESULTADOS EN: {self.results_dir}

INSTRUCCIONES ESPEC√çFICAS:
- Crea discovery_cli.py como archivo principal
- Implementa clases: ExcelParser, OutputManager, CLIInterface
- C√≥digo debe ser ejecutable directamente
- Incluye ejemplo de uso en comentarios

EMPIEZA INMEDIATAMENTE. Coordina con Backend para interfaces.
"""

        backend_mission = f"""
üéØ MISI√ìN CR√çTICA: MOTOR DE DESCUBRIMIENTO - BACKEND SPECIALIST

OBJETIVO PRINCIPAL:
Construir motor de descubrimiento en tiempo real que ingiera Excel con temas/consultas,
busque exhaustivamente, extraiga metadatos, deduplique y ejecute continuamente.

TU RESPONSABILIDAD ESPEC√çFICA (BACKEND):

1. PROVIDERS MODULARES:
   - AbstractProvider interface base
   - WebSearchProvider (requests + BeautifulSoup/trafilatura)
   - RSSProvider (feedparser)
   - RedditProvider (praw)
   - YouTubeProvider (youtube-dl/yt-dlp)
   - TwitterProvider (tweepy si es posible)

2. MOTOR DE CRAWLING:
   - Profundidad configurable por topic
   - Expansi√≥n M√ÅS ALL√Å de semillas iniciales
   - Concurrencia con asyncio/aiohttp
   - Rate limiting y retries por dominio
   - L√≠mites configurables --max-crawl-per-domain

3. EXTRACCI√ìN Y NORMALIZACI√ìN:
   - Usar trafilatura para texto principal
   - Extraer metadatos: title, text, author, published_at, domain
   - Limpieza y normalizaci√≥n de datos
   - Manejo robusto de errores

4. DEDUPLICACI√ìN Y SCORING:
   - Content-based hashing para duplicados
   - Fuzzy matching para similarity
   - Scoring por relevancia/recencia/diversidad
   - Persistencia entre rondas

5. COORDINACI√ìN CON FRONTEND:
   - Define API clara: discover_content(topic, config) -> List[DiscoveredItem]
   - Formato DiscoveredItem: title, text, author, published_at, domain, relevance_score
   - Integraci√≥n asyncio para no bloquear

DIRECTORIO DE TRABAJO: {self.agent_backend.code_output_dir}

INSTRUCCIONES ESPEC√çFICAS:
- Crea discovery_engine.py como motor principal
- Implementa providers/ directory con cada provider
- Incluye deduplication.py y scoring.py
- C√≥digo debe ser importable por Frontend

EMPIEZA INMEDIATAMENTE. Coordina con Frontend para interfaces.
"""
        
        # Enviar misiones a ambos agentes
        await self.agent_frontend.send_mission(frontend_mission)
        await self.agent_backend.send_mission(backend_mission)
        
        # Log de sesi√≥n
        with open(self.session_log, 'w', encoding='utf-8') as f:
            f.write(f"SESI√ìN INICIADA: {datetime.now().isoformat()}\n")
            f.write(f"DIRECTORIO DE SALIDA: {self.output_dir}\n")
            f.write(f"AGENTES: AgentA (Frontend), AgentB (Backend)\n")
            f.write(f"MISI√ìN: Motor de Descubrimiento en Tiempo Real\n")
            f.write("="*60 + "\n")
        
        logger.info("üéØ Misiones asignadas a ambos agentes")
        logger.info("‚ö° AUTONOM√çA M√ÅXIMA ACTIVADA")
        
    async def monitor_agents(self, duration_minutes: int = 30):
        """Monitorear agentes trabajando"""
        logger.info(f"üìä Monitoreando agentes por {duration_minutes} minutos...")
        logger.info(f"üìÅ Archivos se guardan en: {self.output_dir}")
        logger.info(f"üí¨ Conversaciones en: {self.agent_frontend.conversation_file} y {self.agent_backend.conversation_file}")
        logger.info(f"üíª C√≥digo en: {self.agent_frontend.code_output_dir} y {self.agent_backend.code_output_dir}")
        
        end_time = time.time() + (duration_minutes * 60)
        
        while time.time() < end_time:
            if not (self.agent_frontend.is_active and self.agent_backend.is_active):
                logger.warning("‚ö†Ô∏è Uno o ambos agentes se desconectaron")
                break
            
            # Leer outputs peri√≥dicamente
            frontend_output = await self.agent_frontend.read_output()
            backend_output = await self.agent_backend.read_output()
            
            if frontend_output:
                logger.info(f"üì• Frontend: Nueva actividad ({len(frontend_output)} l√≠neas)")
            
            if backend_output:
                logger.info(f"üì• Backend: Nueva actividad ({len(backend_output)} l√≠neas)")
            
            # Verificar archivos creados
            frontend_files = list(self.agent_frontend.code_output_dir.glob("*.py"))
            backend_files = list(self.agent_backend.code_output_dir.glob("*.py"))
            
            if frontend_files or backend_files:
                logger.info(f"üìÅ Archivos creados - Frontend: {len(frontend_files)}, Backend: {len(backend_files)}")
            
            await asyncio.sleep(30)  # Check every 30 seconds
        
        logger.info("‚è∞ Tiempo de monitoreo completado")
        
    def show_results_summary(self):
        """Mostrar resumen de resultados"""
        logger.info("üìä RESUMEN DE RESULTADOS:")
        logger.info("="*50)
        
        # Archivos creados por frontend
        frontend_files = list(self.agent_frontend.code_output_dir.glob("*"))
        logger.info(f"üé® Frontend cre√≥ {len(frontend_files)} archivos:")
        for file in frontend_files:
            logger.info(f"  üìÑ {file.name}")
        
        # Archivos creados por backend
        backend_files = list(self.agent_backend.code_output_dir.glob("*"))
        logger.info(f"üîß Backend cre√≥ {len(backend_files)} archivos:")
        for file in backend_files:
            logger.info(f"  üìÑ {file.name}")
        
        # Conversaciones
        if self.agent_frontend.conversation_file.exists():
            size = self.agent_frontend.conversation_file.stat().st_size
            logger.info(f"üí¨ Conversaci√≥n Frontend: {size} bytes")
        
        if self.agent_backend.conversation_file.exists():
            size = self.agent_backend.conversation_file.stat().st_size
            logger.info(f"üí¨ Conversaci√≥n Backend: {size} bytes")
        
        logger.info(f"üìÅ Todos los resultados en: {self.output_dir}")
        
    def cleanup(self):
        """Limpiar agentes"""
        logger.info("üßπ Limpiando agentes...")
        self.agent_frontend.stop()
        self.agent_backend.stop()

@click.command()
@click.option('--output-dir', default=f'./discovery_output_{datetime.now().strftime("%Y%m%d_%H%M%S")}', 
              help='Directorio donde guardar todos los resultados')
@click.option('--duration', default=30, help='Duraci√≥n del monitoreo en minutos')
@click.option('--auto-start', is_flag=True, help='Iniciar autom√°ticamente sin confirmaci√≥n')
def main(output_dir, duration, auto_start):
    """
    Lanzar 2 agentes Claude CLI reales para implementar motor de descubrimiento
    """
    
    logger.info("üöÄ LANZADOR DE AGENTES CLAUDE CLI REALES")
    logger.info("üéØ Objetivo: Motor de Descubrimiento en Tiempo Real")
    logger.info(f"üìÅ Resultados se guardar√°n en: {output_dir}")
    
    if not auto_start:
        response = input(f"\n¬øContinuar con agentes Claude CLI reales? (y/N): ")
        if response.lower() != 'y':
            logger.info("‚ùå Operaci√≥n cancelada")
            return
    
    async def run_real_agents():
        output_path = Path(output_dir)
        orchestrator = RealAgentOrchestrator(output_path)
        
        try:
            # Configurar agentes
            if not await orchestrator.setup_agents():
                return
            
            # Asignar misi√≥n
            await orchestrator.assign_discovery_mission()
            
            logger.info("ü§ñ AGENTES TRABAJANDO AUT√ìNOMAMENTE")
            logger.info("üîÑ Implementando motor de descubrimiento sin supervisi√≥n")
            logger.info(f"‚è∞ Monitoreo por {duration} minutos")
            logger.info("‚èπÔ∏è  Presiona Ctrl+C para detener antes")
            
            # Monitorear trabajo
            await orchestrator.monitor_agents(duration)
            
            # Mostrar resultados
            orchestrator.show_results_summary()
            
            logger.info("‚úÖ AGENTES CLAUDE CLI COMPLETARON SU TRABAJO")
            
        except KeyboardInterrupt:
            logger.info("üõë Detenido por usuario")
        except Exception as e:
            logger.error(f"‚ùå Error: {e}")
        finally:
            orchestrator.cleanup()
    
    asyncio.run(run_real_agents())

if __name__ == "__main__":
    main()